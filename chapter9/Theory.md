О процессах, потоках и горутинах   
   
    Процесс — это среда выполнения, в которой содержатся инструкции, пользователь-
ские данные и части системных данных, а также другие типы ресурсов, полученные
во время выполнения программы, тогда как сама программа — это файл, в котором
содержатся инструкции и данные, используемые для инициализации инструкций
и пользовательских данных процесса.

    Поток — это меньшая и более легкая сущность, чем процесс или программа.
Потоки создаются процессами, имеют собственный процесс управления и стек.
Быстрый и простой способ отличить поток от процесса — рассматривать процесс
как исполняемый двоичный файл, а поток — как подмножество процесса.

    Горутина — это минимальная сущность Go, которая может быть выполнена
конкурентно. Использование слова «минимальная» здесь очень важно, поскольку
горутины не являются автономными сущностями, такими как процессы UNIX, —
горутины живут в потоках UNIX, которые, в свою очередь, живут в процессах
UNIX. Основным преимуществом горутин является то, что они чрезвычайно лег-
кие, так что запуск тысяч или сотен тысяч горутин на одной машине не является
проблемой.

    Горутины легче потоков, которые, в свою очередь, легче процессов. На практике
это означает, что в процессе может быть несколько потоков и множество горутин,
в то время как горутина может существовать только в среде процесса. Таким обра-
зом, для создания горутины необходим процесс хотя бы с одним потоком — о про-
цессах и управлении потоками позаботится UNIX, а Go и разработчик должны
подумать о горутинах.
Теперь, когда вы познакомились с основными свойствами процессов, программ,
потоков и горутин, поговорим немного о планировщике Go.


-------------------------Конкурентность и параллелизм----------------------------------

Бытует очень распространенное заблуждение о том, что конкурентность и парал-
лелизм — одно и то же. Это просто неправда! Параллелизм — это одновременное
выполнение нескольких сущностей определенного вида, тогда как конкурент-
ность — способ структурирования компонентов, позволяющий им выполняться
независимо, когда это возможно.

    Разработка конкурентных программных компонентов — необходимое условие
того, что их можно будет безопасно выполнять параллельно, когда и если операци-
онная система и оборудование это позволят. Это давным-давно было реализовано
в языке программирования Erlang — задолго до появления многоядерных процес-
соров и компьютеров с большим объемом оперативной памяти.

    В правильной конкурентной архитектуре добавление конкурентных сущностей
приводит к тому, что вся система начинает работать быстрее, потому что в ней
больше задач может выполняться параллельно. Таким образом, чтобы достичь
желаемой степени параллелизма, необходимо обеспечить наилучшее конкурентное
описание и реализацию задачи. Разработчик должен учитывать конкурентность на
этапе проектирования системы — только тогда он получит выгоду от потенциально-
го параллельного выполнения системных компонентов. Таким образом, разработчик
должен думать не о параллелизме, а о том, как разбить систему на независимые
компоненты, которые, будучи объединенными, решали бы исходную задачу.

    Даже если на вашем компьютере с UNIX разработанные вами функции не могут
выполняться параллельно, правильное конкурентное построение программы все
равно улучшит ее структуру и удобство сопровождения. Другими словами, конку-
рентность лучше параллелизма!


------------------------ГОРУТИНЫ--------------------------

Чтобы определить, создать и выполнить новую горутину, нужно воспользоваться клю-
чевым словом go, после которого поставить имя функции или полное определение ано-
нимной функции. Ключевое слово go приводит к немедленному возврату (в основной
поток) после вызова функции, в то время как сама функция выполняется в фоновом
режиме как горутина, а остальная программа тем временем продолжает выполнение.

    Однако, как вы скоро узнаете, мы не можем контролировать или делать какие-
либо предположения о последовательности выполнения горутин, поскольку это
зависит от планировщика операционной системы, планировщика Go и степени
загрузки операционной системы.


--------------------------КАНАЛЫ--------------------------

    Канал — это механизм коммуникации, который, помимо прочего, позволяет обме-
ниваться данными между горутинами.

Однако здесь есть ряд правил. Во-первых, каждый канал позволяет обмени-
ваться данными определенного типа, который называется типом элемента канала.
Во-вторых, для правильной работы канала необходим кто-то, кто будет получать
то, что отправляется через канал. Чтобы создать новый канал, нужно использовать
ключевое слово chan, а чтобы его закрыть — вызвать функцию close().

    Наконец, еще одна очень важная деталь: используя канал в качестве аргумента
функции, можно указать его направление — будет ли этот канал использоваться для
отправки или получения данных. Я считаю, что, если назначение канала заранее
известно, следует использовать эту возможность, поскольку это сделает програм-
мы надежнее и безопаснее. Вы не сможете случайно отправить данные в канал, из
которого можно только получать данные, или получать данные из канала, в который
данные можно только отправлять. В результате, если вы объявите, что канал — ар-
гумент функции будет использоваться только для чтения, и попытаетесь записать
в него данные, то получите сообщение об ошибке, которое, скорее всего, избавит вас
от неприятных программных дефектов.


--------------------------КОНВЕЙЕРЫ-----------------------------------

    Конвейер — это виртуальный метод, предназначенный для соединения горутин
и каналов, так что выходные данные одной горутины становятся входными данны-
ми для другой горутины, а для передачи данных используются каналы.

    Одним из преимуществ использования конвейеров является наличие постоян-
ного потока данных, так что никакие горутины и каналы не должны ожидать, пока
завершится все остальное, чтобы можно было начать выполнение. Кроме того, мы
используем меньше переменных и, следовательно, меньше памяти, потому что
не приходится сохранять все данные в виде переменных. Наконец, использование
конвейеров упрощает разработку программ и делает их удобнее для поддержки.