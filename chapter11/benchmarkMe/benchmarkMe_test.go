// go test -bench=. benchmarkMe.go benchmarkMe_test.go

// Здесь два важных момента: во-первых, значение параметра -bench определяет,
// какие именно функции бенчмаркинга будут выполняться. Использованное зна-
// чение . — это регулярное выражение, которое соответствует всем допустимым
// функциям бенчмаркинга. Во-вторых, если опустить параметр -bench, то ни одна
// функция бенчмаркинга не будет выполнена.

// goos: linux
// goarch: amd64
// cpu: 13th Gen Intel(R) Core(TM) i7-13700H
// Benchmark30fibo1-20          326           3574581 ns/op
// Benchmark30fibo2-20          298           3977613 ns/op
// Benchmark30fibo3-20       481353              2655 ns/op
// Benchmark50fibo1-20            1        53771505436 ns/op
// Benchmark50fibo2-20            1        59881919586 ns/op
// Benchmark50fibo3-20       410932              3004 ns/op
// PASS
// ok      command-line-arguments  119.362s

// Прежде всего, -20 в конце каждой тестовой
// функции (Benchmark10fibo1-20) означает количество горутин, использованных
// во время ее выполнения, что, по сути, является значением переменной среды
// GOMAXPROCS.

// Во втором столбце результатов показано, сколько раз была выполнена соответ-
// ствующая функция. Более быстрые функции выполняются чаще, чем медленные.
// Например, функция Benchmark30fibo3() была выполнена 481353 раз, а функция
// Benchmark50fibo2() — только один раз! В третьем столбце отображается среднее
// время каждого выполнения функции.

// Если вы хотите включить в результаты бенчмаркинга статистику выделе-
// ния памяти, то выполните следующую команду:
// $ go test -benchmem -bench=. benchmarkMe.go benchmarkMe_test.go
package main

import "testing"

var result int

// В этом коде мы видим реализацию функции, имя которой начинается с bench­
// mark, а не с Benchmark. В результате эта функция не будет запускаться автоматиче-
// ски, поскольку ее имя начинается со строчной буквы b вместо прописной B.
// Результат fibo1(n) сначала сохраняется в переменной r, а потом используется
// другой глобальной переменной с именем result по одной хитрой причине: этот
// прием не позволяет компилятору выполнять любые оптимизации, которые бы от-
// менили запуск функции, производительность которой мы хотим измерить, из-за
// того, что результаты этой функции никогда не используются. Тот же прием будет
// применен к функциям benchmarkfibo2() и benchmarkfibo3(), которые мы рассмо-
// трим далее.
func benchmarkfibo1(b *testing.B, n int) {
	var r int
	for i := 0; i < b.N; i++ {
		r = fibo1(n)
	}
	result = r
}

// В этом коде определены еще две тестовые функции, которые не будут запу-
// скаться автоматически, поскольку их имена начинаются со строчной буквы b ,
// а не с прописной B.
// Теперь я открою вам большой секрет: даже если бы эти три функции называ-
// лись BenchmarkFibo1(), BenchmarkFibo2() и BenchmarkFibo3(), они бы не вызы-
// вались автоматически командой go test, поскольку не соответствуют сигнатуре
// func(*testing.B) . Именно поэтому их имена начинаются со строчных букв b .
// Однако, как вы вскоре увидите, ничто не мешает нам вызывать эти функции из
// других функций бенчмаркинга.
func benchmarkfibo2(b *testing.B, n int) {
	var r int
	for i := 0; i < b.N; i++ {
		r = fibo2(n)
	}
	result = r
}

func benchmarkfibo3(b *testing.B, n int) {
	var r int
	for i := 0; i < b.N; i++ {
		r = fibo3(n)
	}
	result = r
}

// Это корректная тестовая функция с правильным именем и правильной сигна-
// турой, следовательно, она будет выполнена командой go tool.
// Обратите внимание, что Benchmark30fibo1() является допустимым именем
// функции бенчмаркинга, а BenchmarkfiboIII() — нет, потому что после слова
// Benchmark не стоит заглавная буква или цифра. Это очень важно, так как функция
// бенчмаркинга с некорректным именем не будет запускаться автоматически. Это же
// правило применяется и к тестовым функциям.
func Benchmark30fibo1(b *testing.B) {
	benchmarkfibo1(b, 30)
}

func Benchmark30fibo2(b *testing.B) {
	benchmarkfibo2(b, 30)
}

func Benchmark30fibo3(b *testing.B) {
	benchmarkfibo3(b, 30)
}

func Benchmark50fibo1(b *testing.B) {
	benchmarkfibo1(b, 50)
}

func Benchmark50fibo2(b *testing.B) {
	benchmarkfibo2(b, 50)
}

func Benchmark50fibo3(b *testing.B) {
	benchmarkfibo3(b, 50)
}
