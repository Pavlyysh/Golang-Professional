------------------------ Планировщик Go ------------------------------------

    В Go используется модель конкурентности fork-join. Слово fork (вилка) в на-
звании модели говорит о том, что дочерняя ветвь может быть создана в любой
точке программы. Аналогично слово join («объединение») говорит о том, что
в некоторой точке дочерняя ветвь заканчивается и объединяется с родительской.
Точками такого объединения, в частности, являются операторы sync.Wait() и ка-
налы, которые собирают результаты выполнения горутин, тогда как каждая новая
горутина создает дочернюю ветвь.

    тратегия справедливого планирования довольно проста концептуально и име-
ет простую реализацию. Согласно этой стратегии, вся нагрузка должна равномерно
распределяться между доступными процессорами. Поначалу такая стратегия может
показаться идеальной, поскольку приходится учитывать не так уж много нюансов,
при этом сохраняя одинаковую нагрузку всех процессоров. Однако на поверку
оказывается, что это не совсем так, поскольку большинство распределенных за-
дач обычно зависят друг от друга, из-за чего некоторые процессоры оказываются
недостаточно загружены, или, что то же самое, одни процессоры используются
интенсивнее, чем другие.

    Горутина в Go — это задача, а все, что происходит после вызова горутины, яв-
ляется продолжением. В стратегии перехвата работы, используемой планировщи-
ком Go, недостаточно загруженный (логический) процессор ищет дополнительную
работу, которую выполняют другие процессоры. Найдя такие задания, он перехва-
тывает их у другого процессора или нескольких процессоров — отсюда и название.
Кроме того, алгоритм перехвата работы в Go перехватывает продолжения и ставит
их в очередь. Останавливающее соединение, как следует из названия, — это место,
в котором поток выполнения останавливается в точке соединения и начинает ис-
кать себе другую работу.

    Несмотря на то что и при перехвате задач, и при перехвате продолжений имеет
место останавливающее соединение, продолжения случаются чаще, чем задачи;
поэтому алгоритм Go работает не с задачами, а с продолжениями.

-------------------------------------------------------------------------------------

    Общая память и общие переменные — наиболее распространенные способы взаи-   
модействия потоков UNIX между собой.
    
    Переменные мьютекса (сокращенное mutual exclusion — «взаимное исключе-
ние») используются главным образом для синхронизации потоков и для защиты
общих данных, когда нужно исключить возможность одновременного выполне-
ния нескольких операций записи. Мьютекс работает как буферизованный канал
с емкостью, равной единице, так что в любой момент только одна горутина имеет
доступ к общей переменной. Это означает, что две и более горутины не могут из-
менить эту переменную одновременно.
    
    Код, который не может выполняться одновременно всеми процессами, потока-
ми или в данном случае горутинами, называется критическим разделом конкурент-
ной программы. Такой код должен быть защищен мьютексами. Таким образом, 
определение критических разделов кода упростит весь процесс программирования,
поэтому следует уделить особое внимание данной задаче.


-------------------------------------Mutex---------------------------------------------

    В определении типа sync.Mutex нет ничего необычного. Основная работа вы-
полняется функциями sync.Lock() и sync.Unlock(), первая из которых блокирует,
а вторая разблокирует мьютекс sync.Mutex. Когда мьютекс блокирован, это озна-
чает, что никто другой не может заблокировать этот мьютекс, пока он не будет
освобожден с помощью функции sync.Unlock().

------------------------------------RWMutex--------------------------------------------

    Несмотря на то что только одной функции разрешается выполнять операции за-
писи с мьютексом sync.RWMutex, у нас может быть несколько функций, владеющих
мьютексом sync.RWMutex и выполняющих чтение. Однако следует учитывать, что,
пока все функции, читающие мьютекс типа sync.RWMutex, не разблокируют этот
мьютекс, вы не сможете заблокировать его для записи — не особенно большая цена
за возможность разрешить несколько операций чтения.

    Работать с мьютексом sync.RWMutex вам помогут функции RLock() и RUnlock(),
которые блокируют и разблокируют мьютекс для чтения соответственно. Функ-
ции Lock() и Unlock(), используемые в мьютексе sync.Mutex, по-прежнему при-
меняются для того, чтобы заблокировать и разблокировать мьютекс sync.RWMutex
для записи. Таким образом, вызов функции RLock(), которая блокирует мьютекс
для чтения, должен быть связан с вызовом функции RUnlock(). Наконец, как вы,
очевидно, понимаете, не следует изменять какие-либо общие переменные внутри
блока кода, расположенного между RLock() и RUnlock().