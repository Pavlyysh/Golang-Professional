// Пакет viper — мощный Go-пакет, который поддерживает большое количество
// опций. Все проекты viper соответствуют единому шаблону. Сначала нужно ини-
// циализировать viper, а затем определить интересующие вас элементы. После этого
// вы получаете доступ к этим элементам, можете читать и использовать их значения.
// Обратите внимание, что пакет viper способен полностью заменить пакет flag.
// Нужные значения можно получить либо напрямую, как при использовании
// пакета flag стандартной библиотеки Go, так и косвенно, с помощью файлов
// конфигурации. При использовании файлов конфигурации, в которых свойства
// представлены в формате JSON, YAML, TOML, HCL или Java, viper автоматиче-
// ски выполняет весь синтаксический анализ, что избавляет вас от необходимости
// писать и отлаживать большой объем кода Go. Пакет viper также позволяет из-
// влекать значения из структур Go и сохранять их в этих структурах. Однако для
// этого необходимо, чтобы поля структуры Go соответствовали ключам файла
// конфигурации.
// Домашняя страница пакета viper находится на GitHub (https://github.com/spf13/
// viper). Обратите внимание, что вы не обязаны использовать все возможности viper
// в своих утилитах — применяйте только те из них, которые вам действительно
// нужны. Общее правило заключается в том, чтобы использовать те функции viper,
// которые упрощают код. Иначе говоря, если вашей утилите требуется слишком
// много аргументов и флагов командной строки, то лучше использовать файл кон-
// фигурации.

package main

import (
	"fmt"

	"github.com/spf13/viper"
)

func main() {
	viper.BindEnv("GOMAXPROCS")
	val := viper.Get("GOMAXPROCS")
	fmt.Println("GOMAXPROCS:", val)
	viper.Set("GOMAXPROCS", 10)
	val = viper.Get("GOMAXPROCS")
	fmt.Println("GOMAXPROCS:", val)

	viper.BindEnv("NEW_VARIABLE")
	val = viper.Get("NEW_VARIABLE")
	if val == nil {
		fmt.Println("NEW_VARIABLE not defined.")
		return
	}
	fmt.Println(val)
}
